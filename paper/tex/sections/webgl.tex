\section{WebGL}
\subsection{Funktionsweise}
WebGL basiert auf der OpenGL ES (Embedded Systems) API \cite{parisi2012webgl} einer reduzierten Version der OpenGL API \cite{KhronosGLES}. Reduziert bezieht sich in diesem Falle jedoch primär auf das Entfernen von Abwärtskompatibilität (\zb fixed-function pipeline) sowie das Wegfallen von Funktionen die softwareseitig durch einfachere Funktionen ersetzt werden (\zb Kein direktes rendering von Quads) \cite{DiffGLES}. Daher können selbst state-of-the-art Engines wie die Unreal Engine mit geringen Einschränkungen verwendet werden, um WebGL Projekte zu realisieren \cite{UnrealHTML5}\cite{UnrealLimits}. \\
Da es sich bei WebGL somit um eine low-level Grafikapi handelt, ist die Entwicklung von Anwendung direkt in WebGL sehr zeitaufwendig und setzt fortgeschrittenes Know-how in Grafikprogrammierung voraus. Daher gibt es einige Frameworks und Game Engines die durch Abstraktionen die Entwicklung wesentlich erleichtern \cite{parisi2012webgl}. Eine exemplarische Übersicht über diese wird in den folgenden Kapiteln gezeigt. \\
Für die Verwendung von WebGL in einer Website wird ein HTML5 canvas Element als Interface zwischen der \ac{DOM} und WebGL benötigt. Von diesem canvas Element kann dann ein WebGL Kontext erzeugt werden \cite{parisi2012webgl}. Dieser Kontext wird dann als Interface für alle folgenden WebGL Operationen verwendet. Konkret würde eine Anwendung 3D Modelle und Texturen laden \bzw erzeugen, diese in Puffer laden, um diese dann mithilfe von Shaderprogrammen auf den Canvas Framebuffer zu rendern. 
\subsection{Vorteile und Nachteile}
Um die Vor- und Nachteile von WebGL zu erläutern, werden wir WebGL mit den Webtechnologien Canvas2D, CSS 3D transform und SVG vergleichen. Durch die grundlegende, im vorrangehenden Kapitel beschriebene Ähnlichkeit von WebGL und nativen Grafikapis, wie OpenGL und DirectX, werden diese nicht weiter verglichen.

\begin{table}[ht]
    \centering
    \begin{tabular}{|P{2.5cm}|P{2.5cm}|P{2.5cm}|P{2.5cm}|P{2.5cm}|}
        \hline
        Eigenschaften & WebGL & Canvas2D & CSS 3D &  SVG \\ \hline
        3D & \checkmark & \cross & \checkmark & \cross \\ \hline
        inline HTML & \cross (Proposed) & \cross & \checkmark & \cross \\ \hline
        CSS  & \cross & \cross & \checkmark & \checkmark \\ \hline
        VR & \checkmark & \cross & \cross & \cross \\ \hline
    \end{tabular}
    \caption{Übersicht Eigenschaften von Webgrafiktechnologien}
    \label{table:CompWebtech}
\end{table}

\subsubsection*{Canvas2D}
und WebGL sind sich in der Art der Einbindung in Websites sehr ähnlich. Beide sind als Context eines Canvas HTML5 Elements verfügbar. Wie der Name vermuten lässt ist Canvas2D jedoch auf hardware beschleunigte 2D Grafiken optimiert (Primitive 3D Grafik ist durch softwareseitige Emulation möglich). Dadurch ist es leichter zu verwenden, da der Programmierer sich nicht um low-level Details kümmern muss, sondern direkt 2D Primitive wie Rechtecke, Linien und Kreise zeichnen kann.
\subsubsection*{CSS3d}
bezeichnet eine Reihe von Erweiterung von CSS die das manipulieren von \ac{DOM} Objekten im dreidimensionalen Raum erlauben. Ein Beispiel hierfür ist auf \url{https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d} verfügbar. Da alle 3D Element Teil der \ac{DOM} sind, ist CSS3D nicht für komplexe Anwendung optimiert. Besonders Updates der 3D Szene mit vielen Änderung würden zu großen Performanceproblemen führen. Der Haupteinsatzzweck für CSS3D ist somit das Darstellen von regulären, möglicherweise auch komplexen wie etwa ganze (Sub-)Seiten als 3D Objekt. Beispielhaft hierfür ein 3D Würfel aus Youtube Videos \url{https://threejs.org/examples/#css3d_youtube}.
\subsubsection*{\ac{SVG}}
\ac{SVG} wurden ursprünglich als statische vektoralternative für reguläre Bilder verwendet. Durch die Einführung von mächtigerem JavaScript und CSS ist es jedoch heutzutage möglich auch interaktive Grafiken mit SVG darzustellen. Die verbreitete Datenvisualisierungsbibliothek d3.js nutzt zum Beispiel SVG zur Anzeige der Grafiken. SVG verwendet, ähnlich wie CSS3D, \ac{DOM} Elemente zur Objektdefinition. Daher ergeben sich die gleichen Performanceprobleme bei größeren \bzw sehr dynamischen Grafiken. Jedoch ermöglicht die Integration mit der \ac{DOM} nicht nur eine einfachere Programmierung, sondern auch die Nutzung von CSS als mächtiges Gestaltungswerkzeug.
\subsection{Frameworks}
Als Übersicht über die verfügbaren WebGL Frameworks haben wir die zwei beliebtesten Frameworks nach GitHub Stars ausgewählt: three.js (59.9k Stars) und pixi.js (29.2k Stars). Abseits von Grafikanwendung existiert auch eine WegGL beschleunigte Version von Tensorflow, einem bekannten Framework für maschinellem Lernen.
\subsubsection*{three.js} Bei dem mit Abstand beliebtesten Framework handelt es sich um eine Bibliothek, die auf 3D Anwendung spezialisiert ist und versucht den Programmierer durch Abstraktionen zu unterstützen ohne jedoch die Möglichkeiten der Technologie einzuschränken. Three.js bietet daher zum Beispiel Hilfsroutinen, um 3D-Modell- und Texturdateien direkt zu laden, ohne das der Entwickler sich um das Erstellen von Vertex- oder Indexbuffer und deren Drawcalls kümmern muss. Ähnlich können Materialeigenschaften durch Standartklassen \bzw einen in JavaScript verfügbaren Node-basierten Materialbuilder erzeugt werden, ohne das händisch low-level Shadercode geschrieben werden muss. Dieses Node-basierte System ähnelt den Grafischen Materialeditoren in modernen Game Engines, wie \zb Unreal, und Modellierungssoftware, wie \zb Blender. Trotz dieser Abstraktionen erlaubt das Framework trotzdem den Zugriff auf die low-level Komponenten falls dies für den Entwickler erforderlich sein sollte.
\subsubsection*{pixi.js} ist ein Framework, das auf beschleunigte 2D Grafik optimiert ist. Daher hat die Bibliothek zusätzlich ein kompatibles Canvas2D Renderbackend für Geräte, die kein WebGL unterstützen. Als 2D Framework abstrahiert pixi.js den 3D-Geometrieteil mit Vertexbuffern und Modellen komplett. Der Fokus der Funktionalität besteht im Anzeigen von Bildern. Hierfür stellt das Framework Hilfsmethoden für das Erstellen von Spriteanimationen, also das animieren ähnlich eines Zeichentrickfilms, sowie auch komplexer Filter wie Tiefenschärfe und optische Verzerrungen. Obwohl das Framework sehr viele Aspekte von WebGL abstrahiert erlaubt pixi.js trotzdem auch teilweise Zugriff auf low-level Funktionen wie das Nutzen von eigenen Shaderprogrammen.
\subsection{Game Engines}
Beide der momentan am weitesten verbreitesten Game Engines \cite{UnityDist}\cite{EngineDist}, Unity und Unreal Engine, erlauben WebGL als Zielplattform. Trotz der weiten Verbreitung dieser Engines konnten wir jedoch keine bekannten Beispiele für die Nutzung dieser Technologie finden. Dies könnte sich auf die relativ große Buildgröße zurückführen lassen. Diese kann sich besonders bei Unreal Engine auf mehr als 100 Megabyte belaufen (ausschließlich für Code). Daher ist es nicht unbedingt überraschend das die meisten Entwickler leichtgewichtigere Lösungen momentan bevorzugen. Beispiele hierfür sind die im vorherigen Kapitel genannten Frameworks sowie die JavaScript Game Engine PlayCanvas, die sich nach eigenen Angaben großer Beliebtheit bei Firmen wie Disney, Samsung und King erfreut.
