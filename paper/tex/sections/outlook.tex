\section{Ausblick}
\subsection{WebGPU}
Bei WebGPU handelt es sich nicht um einen direkten Nachfolger für WebGL, sondern um eine alternative, unabhängige API \cite{WebGPUIntro}. Das auf OpenGL ES basierend WebGL wird daher weiterhin erweitert, momentan auch durch eine größere Neuerung, das auf OpenGL ES 3.0 basierende WebGL2 \cite{WebGL2}. Daher wird WebGPU keine größere Neuerungen in Sachen Funktionalität bieten sondern, ähnlich wie die Vulkan API dem Entwickler genauere Kontrolle über die verfügbaren Ressourcen zu geben und von Grund auf Multithreading zu erlauben. \\
Multi-threading im Web erfordert jedoch weitere neue Technologien da JavaScript im Web ausschließlich in einem Thread laufen kann \cite{JSConcurrency}. Daher wird WebGPU wahrscheinlich häufig oder gar ausschließlich Verwendung zusammen mit Service Workern oder \ac{Wasm} finden, da diese Multithreading erlauben.
Die durch low-level Ansatz von WebGPU möglichen Performancegewinne werden wohl vorallem für Highend Spiele und Computeanwendungen interessant sein. Einfachere Visualisierungen werden womöglich weiterhin WebGL bevorzugen da der zusätzliche Entwicklungsaufwand hier vermutlich nicht die notwendigen Vorteile bringen wird. \\
Zurzeit befinden sich WebGL2 sowie WebGPU noch in experimentellen Stadien.
\subsection{\acf{Wasm}}
JavaScript war für lange Zeit die einzige verfügbare Programmiersprache im offenen Web. Moderne, komplexe Webanwendungen (siehe \ref{sec:usecases} für Beispiele) können jedoch schnell an JavaScripts Performancegrenzen geraten \cite{haas2017bringing}. Um dieses Defizit auszugleichen wurde \ac{Wasm} entwickelt. \ac{Wasm} erlaubt die Ausführung von Programmcode in verschienden Programmiersprachen mit nahezu nativer Geschwindigkeit. Hierfür wird der Programmcode in eine binäre Zwischensprache übersetzt, welche vom Browser geladen und ausgeführt werden kann \cite{WasmMDN}. \ac{Wasm} ist jedoch nicht als Ersatz für JavaScript gedacht. Stattdessen können beide zusammen genutzt werden um die Flexibilität von JavaScript mit der Performance von \ac{Wasm} zu verbinden \cite{WasmMDN}. \\
Obwohl \ac{Wasm} ursprünglich primär für die Nutzung mit low-level Sprachen wie C/C++ entwickelt wurde \cite{WasmMDN}, bieten auch einige high-level Sprachen \ac{Wasm} als Kompiliereziel. Beispiele hier für wären C\# \cite{dotnetWASM} oder AssemblyScript eine auf JavaScript basierend statisch typisierte Sprache\cite{AsmScript}.
